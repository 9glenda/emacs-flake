* early-init.el
#+begin_src emacs-lisp :tangle early-init.el
;; -*- lexical-binding: t; no-byte-compile: t; -*-
#+end_src

#+begin_src emacs-lisp :tangle early-init.el
(setq gc-cons-threshold most-positive-fixnum)
(setq package-enable-at-startup nil)
#+end_src

* init.el
;;; init.el ---  -*- lexical-binding: t; no-byte-compile: t -*-
#+begin_src emacs-lisp :tangle yes
;;; init.el --- Initialization -*- lexical-binding: t; -*-
#+end_src

** Startup
*** No welcome screen
#+begin_src emacs-lisp :tangle yes
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
;; (setq initial-scratch-message ";; Emacs Scratch buffer")
#+end_src

** Keep folders clean
#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist `(("." . ,(expand-file-name "/tmp/emacs"))))
(setq auto-save-list-file-prefix (expand-file-name "/tmp/emacs/sessions/")
   auto-save-file-name-transforms `((".*" ,(expand-file-name "/tmp/emacs/auto-saves/") t)))
(setq lock-file-name-transforms
      '(("\\`/.*/\\([^/]+\\)\\'" "/tmp/emacs/lock/\\1" t)))
#+end_src

*** Cache
#+begin_src emacs-lisp :tangle yes
(setq user-emacs-directory (expand-file-name "~/.cache/emacs"))
#+end_src
** use-package
#+begin_src emacs-lisp :tangle yes
(eval-when-compile
(require 'use-package))

(eval-and-compile
  (defun use-package-ensure-ignore (&rest _args) t)
  (setq use-package-ensure-function #'use-package-ensure-ignore)

  ;; (setq use-package-always-defer t)
  (setq use-package-hook-name-suffix nil))

(if init-file-debug
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))

#+end_src

** Visuals
*** Theme
#+begin_src emacs-lisp :tangle yes
(load-theme 'modus-vivendi-tritanopia)
#+end_src
*** Line numbers
#+begin_src emacs-lisp :tangle yes
(column-number-mode)
(global-display-line-numbers-mode t)

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
                term-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Keybindings
*** Evil
#+begin_src emacs-lisp :tangle yes
(use-package evil
  :ensure t
  :demand t
  :init
  (setq evil-want-integration t)
  (progn
    (setq evil-undo-system 'undo-tree)
    (setq evil-want-keybinding nil))
  :commands (evil-mode evil-global-set-key evil-previous-visual-line evil-visual-line evil-next-visual-line)
  :config
  (evil-mode 1)

  (setq evil-want-fine-undo t)


  ;; Keybindings for evilnc
  (define-key evil-normal-state-map (kbd "g c") 'evilnc-comment-or-uncomment-lines)
  (define-key evil-visual-state-map (kbd "g c") 'evilnc-comment-or-uncomment-lines)
  (define-key evil-motion-state-map (kbd "g c") 'evilnc-comment-or-uncomment-lines)
)
#+end_src
**** evil-collection
The warning can be ignored
#+begin_src emacs-lisp :tangle yes
(use-package evil-collection
  :ensure t
  :demand t
  :after evil
  :commands (evil-collection-init)
  :config
  (evil-collection-init)
)
#+end_src
**** Undo Tree
=C-x u= gives you a really nice tree view of your undo history.
This is so useful. I often mess up my undo history which is not possibe anymore with =und-tree=.
#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :ensure t
  :demand t
  :commands (global-undo-tree-mode)
  :config
  (global-undo-tree-mode)
)
#+end_src

**** Evil Commenter
#+begin_src emacs-lisp :tangle yes
(use-package evil-nerd-commenter
  :ensure t
  :after evil
  :commands (evilnc-default-hotkeys)
  :config
  (evilnc-default-hotkeys)
)
#+end_src

**** Drag stuff
#+begin_src emacs-lisp :tangle yes
(use-package visual-regexp-steroids
  :ensure t)

(use-package evil-visualstar
  :ensure t)

#+end_src

*** General keybindings
**** which-key
#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :commands (which-key-mode)
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1)
)
#+end_src
**** Ehelloval to kill ring
#+begin_src emacs-lisp :tangle yes
(defun eval-to-kill-ring ()
  (interactive)
  (kill-new (with-output-to-string (princ (call-interactively 'eval-expression)))))

(global-set-key (kbd "C-;") 'eval-to-kill-ring)
#+end_src


**** Clipboard
BUGS: if system clipboard is empty kill ring will be used.
Custom elisp function for C-S-v pasting.
#+begin_src emacs-lisp :tangle yes
(setq select-enable-clipboard nil)

(defun preserve-clipboard (input-function)
  "Executes the function but preserves the clipboard."
  (let ((old-c (when (> (length kill-ring) 0) (car kill-ring))))
    (funcall input-function)
    (when old-c (kill-new old-c))))

(defun copy-to-clipboard ()
  "Copy the selected region to the clipboard."
  (interactive)
  (preserve-clipboard
   (lambda ()
     (setq select-enable-clipboard t)
     (kill-ring-save (region-beginning) (region-end))
     (setq select-enable-clipboard nil))))

(defun paste-from-clipboard ()
  "Paste from the clipboard."
  (interactive)
  (preserve-clipboard
   (lambda ()
     (setq select-enable-clipboard t)
     (yank)
     (setq select-enable-clipboard nil))))

(global-set-key (kbd "C-S-v") 'paste-from-clipboard)
(global-set-key (kbd "C-S-c") 'copy-to-clipboard)
#+end_src


** Completion
*** Company mode

#+begin_src emacs-lisp :tangle yes
(use-package company
  :ensure t
  :demand t
  :after lsp-mode
  :bind (:map company-active-map
         ("<tab>" . company-select-next)
         ("<backtab>" . company-select-previous)
         ("C-j" . company-select-next)
         ("C-k" . company-select-previous)
         ("C-e" . company-abort)
         ("<return>" . company-complete-selection))
  :commands (global-company-mode)
  :config
  (global-company-mode 1)

  (add-to-list 'company-backends 'company-elisp)
  (add-to-list 'company-backends 'company-yasnippet)
  (add-to-list 'company-backends 'company-dabbrev-code)
  (add-to-list 'company-backends 'company-dabbrev)
  (add-to-list 'company-backends 'company-capf)

  (setq company-begin-commands '(self-insert-command))
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay 0.01)
  (setq company-tooltip-align-annotations t)
  ;; (setq company-insertion-triggers '())
)

(use-package company-box
  :ensure t
  :demand t
  :after company
  :hook (company-mode . company-box-mode))
#+end_src

*** Vertico
#+begin_src emacs-lisp :tangle yes
(use-package vertico
  :ensure t
  :commands (vertico-mode)
  :init
  (vertico-mode)
  :custom
  (vertico-cycle t))
#+end_src



*** counsel
#+begin_src emacs-lisp :tangle yes
(use-package counsel
  :ensure t
  :commands (counsel-minnibuffer-history)
  :bind (("M-x" . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("C-x b" . counsel-ibuffer)
         ("C-c f" . counsel-recentf)
         :map minibuffer-local-map
         ("C-r" . counsel-minibuffer-history)))
#+end_src
** Helpful
#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :ensure t
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function) ;; =C-h f=
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable) ;; =C-h v=
  ([remap describe-key] . helpful-key))
#+end_src

** Org
*** No indentation 
#+begin_src emacs-lisp :tangle yes
(use-package org
  :ensure t
  :config
  (setq org-src-preserve-indentation nil
     org-edit-src-content-indentation 0)
  (setq org-ellipsis " â–¾"
      org-hide-emphasis-markers t))
#+end_src

** Scroll
Scroll line by line.
#+begin_src emacs-lisp :tangle yes
(setq scroll-conservatively 100)
#+end_src

** Terminal
*** Ansi term
#+begin_src emacs-lisp :tangle yes
(defvar my-term-shell "/run/current-system/sw/bin/bash")
#+end_src

** Debugging
#+begin_src emacs-lisp :tangle yes
(use-package command-log-mode
  :ensure t)
#+end_src


** LSP
#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :ensure t
  :init
  (setq lsp-keymap-prefix "C-c l") 
  :config
  (lsp-enable-which-key-integration t)
  :commands (lsp lsp-deferred lsp-enable-which-key-integration)
  :hook
  (prog-mode . lsp))
#+end_src
**** LSP UI
#+begin_src emacs-lisp :tangle yes
(use-package lsp-ui
  :ensure t
  :hook (lsp-mode . lsp-ui-mode))
#+end_src
*** Langs
**** Ocaml
#+begin_src emacs-lisp :tangle yes
(use-package tuareg
  :mode "\\.ml\\'"
  :ensure t)
#+end_src


* Keybingings
=M-:= eval-expression
